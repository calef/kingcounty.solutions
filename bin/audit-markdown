#!/usr/bin/env ruby
# frozen_string_literal: true

require 'fileutils'
require 'json'
require 'yaml'
require 'psych'
require 'net/http'
require 'uri'
require 'nokogiri'
require 'front_matter_parser'
require 'addressable/uri'
require 'openai'
require 'time'

OPENAI_MODEL = 'gpt-4o-mini' # explicitly set model
TARGET_DIR = ARGV[0]

if TARGET_DIR.nil? || TARGET_DIR.strip.empty?
  abort <<~USAGE
    Usage:
      ruby audit_content.rb _collection_dir

    Example:
      ruby audit_content.rb _organizations

    Description:
      Audits each markdown file in the given directory against its schema
      (e.g., organizations_schema) from _config.yml. Fetches associated
      website content, validates required and allowed fields locally,
      calls OpenAI for additional review, and rewrites files in place.
      Front matter keys are sorted alphabetically to minimize diffs.
  USAGE
end

abort 'Please set OPENAI_API_KEY in your environment.' unless ENV['OPENAI_API_KEY'] && !ENV['OPENAI_API_KEY'].empty?
abort "Directory not found: #{TARGET_DIR}" unless Dir.exist?(TARGET_DIR)

SCHEMA_KEY = "#{File.basename(TARGET_DIR).sub(/^_/, '')}_schema".freeze
CONFIG_PATH = %w[_config.yml _config.yaml].find { |p| File.exist?(p) } or abort 'Could not find _config.yml'

REPORT_DIR = '_audit_reports'
FileUtils.mkdir_p(REPORT_DIR)
REPORT_PATH = File.join(REPORT_DIR, "audit-#{File.basename(TARGET_DIR)}-#{Time.now.utc.iso8601.gsub(':', '-')}.json")

def load_config_schema(config_path, key)
  cfg = Psych.safe_load_file(config_path, aliases: true) || {}
  schema = cfg[key]
  unless schema
    warn "WARNING: Schema key '#{key}' not found in #{config_path}. Proceeding with minimal schema."
    return {}
  end
  schema
end

def read_markdown(path)
  parser = FrontMatterParser::Parser.new(:md)
  parsed = parser.call(File.read(path))
  { path: path, front_matter: parsed.front_matter || {}, body: parsed.content.to_s }
rescue StandardError => e
  warn "Failed to parse #{path}: #{e.message}"
  { path: path, front_matter: {}, body: '', error: e.message }
end

def write_markdown(path, front_matter, body)
  # 1) Alphabetize keys for stable diffs
  sorted_fm = front_matter.sort.to_h

  # 2) Dump YAML WITHOUT leading '---' (and without trailing '...')
  yaml = Psych.dump(sorted_fm, line_width: -1)
  yaml = yaml.sub(/\A---\s*\n/, '') # remove leading doc marker
  yaml = yaml.sub(/\n?\.\.\.\s*\z/, '') # remove optional YAML terminator

  # 3) Sanitize body so it can't inject another YAML fence
  sanitized = body.to_s
  sanitized = sanitized.sub(/\A\xEF\xBB\xBF/, '')                    # strip BOM
  sanitized = sanitized.sub(/\A\s*---\s*\n.*?\n---\s*\n?/m, '')      # drop full FM block if present
  sanitized = sanitized.sub(/\A\s*---\s*\n?/, '')                    # drop stray opening fence

  # 4) Compose exactly one FM block, normalize extra blank lines, and ensure trailing newline
  new_content = +"---\n#{yaml.strip}\n---\n\n#{sanitized}".gsub(/\n{3,}/, "\n\n")
  new_content = "#{new_content.rstrip}\n"

  File.write(path, new_content)
end

def normalize_url(s)
  return nil if s.nil? || s.to_s.strip.empty?

  uri = Addressable::URI.parse(s.to_s.strip)
  return nil unless uri.scheme && uri.host

  uri.to_s
rescue StandardError
  nil
end

def fetch_url_text(url, limit: 3, timeout: 15)
  return { url: url, ok: false, text: '', error: 'invalid url' } unless normalize_url(url)

  uri = URI(url)
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = (uri.scheme == 'https')
  http.read_timeout = timeout
  http.open_timeout = timeout
  res = http.get(uri.request_uri, { 'User-Agent' => 'KCS-Auditor/1.0' })

  if res.is_a?(Net::HTTPRedirection) && limit.positive?
    return fetch_url_text(res['location'], limit: limit - 1, timeout: timeout)
  end

  return { url: url, ok: false, text: '', error: "HTTP #{res.code}" } unless res.is_a?(Net::HTTPSuccess)

  if res['content-type'].to_s.include?('html')
    doc = Nokogiri::HTML(res.body)
    doc.search('script,style,noscript,header,nav,footer,svg,form').remove
    text = "#{doc.at('title')&.text}\n#{doc.text}"
    { url: url, ok: true, text: text.gsub(/\s+/, ' ').strip[0, 60_000] }
  else
    { url: url, ok: true, text: res.body.to_s.strip[0, 60_000] }
  end
rescue StandardError => e
  { url: url, ok: false, text: '', error: e.message }
end

def guess_website(front_matter)
  %w[website url site homepage home_url link].each do |k|
    return normalize_url(front_matter[k]) if front_matter[k]
  end
  nil
end

def summarize_text(txt, max_chars: 15_000)
  txt.length <= max_chars ? txt : txt[0, max_chars]
end

def client
  @client ||= OpenAI::Client.new(access_token: ENV.fetch('OPENAI_API_KEY', nil))
end

def enforce_schema(front_matter, schema)
  issues = []
  corrected = front_matter.dup

  return [corrected, issues] unless schema.is_a?(Hash) && !schema.empty?

  # Helper lambda: true only for explicit required statements, not negatives
  is_required_rule = ->(rules) do
    return false unless rules.is_a?(Array)
    rules.any? do |r|
      next false unless r.is_a?(String)
      r =~ /\b(the\s+)?field\s+(is|must be)\s+required\b/i
    end
  end

  schema.each do |key, definition|
    next unless definition.is_a?(Hash)

    is_required = is_required_rule.call(definition['rules'])

    # Only add missing keys if they are REQUIRED
    if is_required && !corrected.key?(key)
      issues << { key: key, issue: 'missing_required' }
      corrected[key] = (definition['type'] == 'array') ? [] : nil
      puts "     ü™£ Added missing REQUIRED field: #{key} (initialized as #{corrected[key].inspect})"
    end

    # Validate enums/possible_values only if a value exists
    if corrected.key?(key)
      allowed = definition['enum'] || definition['possible_values']
      if allowed && !allowed.include?(corrected[key])
        issues << { key: key, issue: 'invalid_value', allowed: allowed, actual: corrected[key] }
      end
    end
  end

  [corrected, issues]
end

def schema_keys(schema)
  return [] unless schema.is_a?(Hash)
  schema.keys.map(&:to_s)
end

def openai_review(front_matter:, body:, website_text:, schema:, path:)
  allowed_keys = schema_keys(schema)
  has_topics   = allowed_keys.include?('topics')

  topic_hint = if has_topics
    <<~HINT
      NOTE: The 'topics' field (if present in the schema) lists what kinds of services or programs
      the organization relates to. Use the schema's possible_values to select relevant ones
      from the description or website text.
    HINT
  else
    "" # do not hint about topics when not in schema
  end

  array_hint = <<~HINT
    For array-type fields (e.g., any fields whose type is 'array' in the schema),
    infer or construct appropriate arrays using the schema‚Äôs possible values and the provided text.
  HINT

  prompt = <<~PROMPT
    You are auditing content for accuracy. Review the following markdown record
    for correctness and completeness. Use the provided website text for validation.

    #{topic_hint}#{array_hint}

    ALLOWED FRONT-MATTER KEYS (must not introduce keys outside this list):
    #{allowed_keys.join(', ')}

    SCHEMA (YAML):
    #{schema.to_yaml}

    FRONT MATTER (YAML):
    #{front_matter.to_yaml}

    BODY:
    #{body.empty? ? '(none)' : body}

    WEBSITE TEXT (truncated):
    #{summarize_text(website_text)}

    TASK:
    - Verify each key‚Äôs value accuracy and propose updates if needed.
    - Do not change the value of a key to be less specific than the prior key. For example, changing from a region of a county to a county for a parent_place.
    - Add all REQUIRED fields from the schema if missing.
    - Do NOT add optional fields unless you can confidently populate them with non-empty values.
    - For array-type fields that are REQUIRED, infer or construct arrays using schema possible_values and the provided text. If you cannot infer, use an empty array so the REQUIRED field exists.   - Do NOT introduce any new keys beyond the allowed list above.
    - If a REQUIRED array field cannot be confidently filled, include an empty array so that the field exists.
    - If text body is empty or outdated, propose a replacement written in markdown.
    - Ensure that the text body is written in the third person.

    Return STRICT JSON ONLY in this structure:

    {
      "frontmatter": {
        "<key>": { "action": "keep|update|add", "proposed": <value or null>, "reason": "<why>" },
        ...
      },
      "body": {
        "action": "keep|update|add",
        "proposed_markdown": "<markdown>",
        "reason": "<why>"
      }
    }
  PROMPT

  response = client.chat(
    parameters: {
      model: OPENAI_MODEL,
      temperature: 0,
      response_format: { type: 'json_object' },
      messages: [
        { role: 'system', content: 'You are a precise content auditor. Respond only with valid JSON.' },
        { role: 'user', content: prompt }
      ]
    }
  )

  content = response.dig('choices', 0, 'message', 'content').to_s
  JSON.parse(content)
rescue StandardError => e
  warn "OpenAI error for #{path}: #{e.message}"
  { 'error' => e.message }
end

def apply_openai_changes(front_matter, body, review, schema: {})
  allowed = schema_keys(schema)
  fm = front_matter.dup

  (review['frontmatter'] || {}).each do |key, data|
    key_str = key.to_s
    next unless data.is_a?(Hash)

    # Only apply if key already exists OR is in schema‚Äôs allowed keys
    next unless fm.key?(key_str) || allowed.include?(key_str)

    case data['action']
    when 'add', 'update'
      proposed = data['proposed']
      # Accept nil only if field is allowed to be nil; otherwise skip silently
      fm[key_str] = proposed unless proposed.nil?
    when 'keep'
      # nothing
    end
  end

  new_body = body
  if review['body']
    case review['body']['action']
    when 'add', 'update'
      proposed_md = review['body']['proposed_markdown'].to_s
      new_body = proposed_md if !proposed_md.strip.empty?
    end
  end

  [fm, new_body]
end

schema = load_config_schema(CONFIG_PATH, SCHEMA_KEY)
files = Dir.glob(File.join(TARGET_DIR, '**', '*.md'))
abort "No markdown files found in #{TARGET_DIR}" if files.empty?

puts "üîç Starting audit for #{files.size} file(s) in #{TARGET_DIR}"
puts "   Using schema key: #{SCHEMA_KEY}"
puts '   Writing changes directly to files...'
puts '------------------------------------------------------------'

report = {
  directory: TARGET_DIR,
  schema_key: SCHEMA_KEY,
  model: OPENAI_MODEL,
  started_at: Time.now.utc.iso8601,
  items: []
}

files.each_with_index do |path, idx|
  puts "\n[#{idx + 1}/#{files.size}] Processing #{path}..."

  parsed = read_markdown(path)
  fm = parsed[:front_matter]
  body = parsed[:body]

  puts '   ‚Üí Enforcing schema...'
  fm, schema_issues = enforce_schema(fm, schema)
  puts "     ‚ö†Ô∏è  Schema issues detected: #{schema_issues.map { |i| i[:key] }.join(', ')}" unless schema_issues.empty?

  website = guess_website(fm)
  if website
    puts "   ‚Üí Fetching website: #{website}"
    capture = fetch_url_text(website)
  else
    puts '   ‚Üí No website found in front matter.'
    capture = { text: '' }
  end

  puts '   ‚Üí Running OpenAI review...'
  review = openai_review(
    front_matter: fm,
    body: body,
    website_text: capture[:text],
    schema: schema,
    path: path
  )

  new_fm, new_body = apply_openai_changes(fm, body, review)

  puts '   ‚Üí Writing updated file...'
  write_markdown(path, new_fm, new_body)

  report[:items] << {
    path: path,
    website: website,
    schema_issues: schema_issues,
    front_matter_before: fm,
    front_matter_after: new_fm,
    body_changed: new_body != body,
    openai_review: review
  }

  puts "   ‚úÖ Completed #{path}"
end

report[:finished_at] = Time.now.utc.iso8601
File.write(REPORT_PATH, JSON.pretty_generate(report))

puts "\n------------------------------------------------------------"
puts "üéâ Audit complete for #{files.size} file(s)."
puts "üóÇÔ∏è  Report written to #{REPORT_PATH}"
puts 'üíæ All documents were updated in place with alphabetically sorted keys.'
