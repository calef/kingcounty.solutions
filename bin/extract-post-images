#!/usr/bin/env ruby
# frozen_string_literal: true

require 'date'
require 'digest'
require 'fileutils'
require 'open-uri'
require 'uri'
require 'yaml'

POSTS_DIR = '_posts'
IMAGE_DOCS_DIR = '_images'
IMAGE_ASSET_DIR = File.join('assets', 'images')
OPEN_TIMEOUT = Integer(ENV.fetch('IMAGE_OPEN_TIMEOUT', '10')) rescue 10
READ_TIMEOUT = Integer(ENV.fetch('IMAGE_READ_TIMEOUT', '30')) rescue 30

FileUtils.mkdir_p(IMAGE_DOCS_DIR)
FileUtils.mkdir_p(IMAGE_ASSET_DIR)

def read_frontmatter(path)
  content = File.read(path)
  unless content =~ /\A---\s*\n(.*?\n?)^---\s*$\n?/m
    warn "Skipping #{path}: missing front matter"
    return [nil, nil]
  end

  data = YAML.safe_load(Regexp.last_match(1), permitted_classes: [Date, Time]) || {}
  body = Regexp.last_match.post_match
  [data, body]
rescue Psych::Exception => e
  warn "Skipping #{path}: #{e.message}"
  [nil, nil]
end

def write_with_frontmatter(path, data, body)
  yaml = data.to_yaml(line_width: -1).sub(/\A---\s*\n/, '')
  safe_body = body.to_s
  separator = safe_body.start_with?("\n") ? '' : "\n"
  File.write(path, +"---\n#{yaml}---\n#{separator}#{safe_body}")
end

def extract_images(markdown)
  results = []

  markdown.to_s.scan(/!\[(.*?)\]\((\S+?)(?:\s+"[^"]*")?\)/m) do |alt, url|
    results << { alt: alt.to_s.strip, url: url.to_s.strip }
  end

  markdown.to_s.scan(/<img[^>]*>/i) do |tag|
    src = tag[/\bsrc\s*=\s*["']([^"']+)["']/i, 1]
    next unless src

    alt = tag[/\balt\s*=\s*["']([^"']*)["']/i, 1]
    results << { alt: alt.to_s.strip, url: src.strip }
  end

  results.reject { |img| img[:url].nil? || img[:url].empty? }
end

def parsed_uri(url)
  URI.parse(url)
rescue URI::InvalidURIError
  nil
end

def valid_image_uri?(uri)
  uri && %w[http https].include?(uri.scheme) && uri.host
end

def image_extension(uri, content_type)
  from_path = File.extname(uri.path).downcase
  return from_path if from_path =~ /\.(jpg|jpeg|png|gif|webp|svg)$/

  case content_type.to_s.split(';').first
  when 'image/jpeg' then '.jpg'
  when 'image/png' then '.png'
  when 'image/gif' then '.gif'
  when 'image/webp' then '.webp'
  when 'image/svg+xml' then '.svg'
  else '.img'
  end
end

def download_image(url)
  uri = parsed_uri(url)
  return nil unless valid_image_uri?(uri)

  URI.open(uri, open_timeout: OPEN_TIMEOUT, read_timeout: READ_TIMEOUT) do |io|
    data = io.read
    ext = image_extension(uri, io.content_type)
    { data: data, ext: ext }
  end
rescue StandardError => e
  warn "Failed to download #{url}: #{e.message}"
  nil
end

def image_asset_filename(checksum, ext)
  filename = "#{checksum}#{ext}"
  path = File.join(IMAGE_ASSET_DIR, filename)
  File.binwrite(path, yield) unless File.exist?(path)
  filename
end

def ensure_image_doc(checksum, alt, filename, post_frontmatter, original_url)
  doc_path = File.join(IMAGE_DOCS_DIR, "#{checksum}.md")
  image_url = "/assets/images/#{filename}"
  source = post_frontmatter['source']
  date = post_frontmatter['date']

  if File.exist?(doc_path)
    existing_data, existing_body = read_frontmatter(doc_path)
    if existing_data
      updated = existing_data.dup
      updated['checksum'] = checksum unless updated['checksum'] == checksum
      updated['image_url'] = image_url
      updated['source_url'] = original_url
      updated['source'] = source if source && source != existing_data['source']
      updated['date'] = date if date && date != existing_data['date']
      updated['title'] = alt unless alt.to_s.strip.empty?

      write_with_frontmatter(doc_path, updated, existing_body) if updated != existing_data
      return
    end
  end

  title = alt.to_s.strip
  frontmatter = {
    'checksum' => checksum,
    'image_url' => image_url,
    'source_url' => original_url
  }
  frontmatter['title'] = title unless title.empty?
  frontmatter['source'] = source if source
  frontmatter['date'] = date if date

  File.write(doc_path, "---\n#{frontmatter.to_yaml.sub(/\A---\s*\n/, '')}---\n")
end

def ensure_empty_images(path, frontmatter, body)
  return if frontmatter['images'].is_a?(Array) && frontmatter['images'].empty?

  frontmatter['images'] = []
  write_with_frontmatter(path, frontmatter, body)
  puts "Updated #{path} with empty images list"
end

def process_post(path, cache)
  frontmatter, body = read_frontmatter(path)
  return unless frontmatter

  if frontmatter['published'] == false
    ensure_empty_images(path, frontmatter, body)
    return
  end

  return if frontmatter.key?('images')

  markdown_body = frontmatter['original_markdown_body']
  unless markdown_body
    ensure_empty_images(path, frontmatter, body)
    return
  end

  images = extract_images(markdown_body)
  if images.empty?
    ensure_empty_images(path, frontmatter, body)
    return
  end

  collected_ids = []

  images.each do |img|
    cached = cache[img[:url]]
    if cached
      collected_ids << cached
      next
    end

    download = download_image(img[:url])
    next unless download

    checksum = Digest::SHA256.hexdigest(download[:data])
    filename = image_asset_filename(checksum, download[:ext]) { download[:data] }
    ensure_image_doc(checksum, img[:alt], filename, frontmatter, img[:url])

    cache[img[:url]] = checksum
    collected_ids << checksum
  end

  collected_ids.uniq!
  if collected_ids.empty?
    ensure_empty_images(path, frontmatter, body)
    return
  end

  existing_ids = Array(frontmatter['images']).map(&:to_s)
  updated_ids = (existing_ids + collected_ids).uniq
  return if updated_ids == existing_ids

  frontmatter['images'] = updated_ids
  write_with_frontmatter(path, frontmatter, body)
  puts "Updated #{path} with #{collected_ids.length} image IDs"
end

def run
  cache = {}
  Dir.glob(File.join(POSTS_DIR, '*.md')).sort.each do |post_path|
    process_post(post_path, cache)
  end
end

run if $PROGRAM_NAME == __FILE__
